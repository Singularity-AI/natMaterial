buildscript {
	repositories {
		mavenCentral()
	}
}

plugins {
	id 'java-library'
	id 'org.springframework.boot' version "${springBoot}"
	id 'io.spring.dependency-management' version "${dependencyManagement}"
	id 'eclipse'
}

/*
----------------------------------------------------------------------------------
From https://docs.gradle.org/current/userguide/multi_project_builds.html
----------------------------------------------------------------------------------
*/

/*
Gradle allows you to access any project of the multi-project build from any build script. 
The Project API provides a method called project(), 
which takes a path as an argument and returns the Project object for this path. 
The capability to configure a project build from any build script we call cross project configuration. 
Gradle implements this via configuration injection.

---------------------------

Other build systems use inheritance as the primary means for defining common behavior. 
We also offer inheritance for projects as you will see later. 
But Gradle uses configuration injection as the usual way of defining common behavior. 
We think it provides a very powerful and flexible way of configuring multiproject builds.

Another possibility for sharing configuration is to use a common external script.
*/
allprojects {		//closure: returns a list with the current project and all its subprojects underneath it
	group = 'it.unibo.springbootexamples'
	version = '0.0.1-SNAPSHOT'
	sourceCompatibility = '1.8'
	
 	
	task hello {	//closure (delegated to the projects)	
					//constructs the task and provides it’s base configuration
        doLast { task ->
            println "Hello, I'm $task.project.name project"
        }
    }
}

/*
The Project API also provides a property for accessing the subprojects only.
*/
subprojects {

	apply plugin: 'org.springframework.boot'
	apply plugin: 'io.spring.dependency-management'
	apply plugin: 'java-library'
	apply plugin: 'java'
	
	
    hello {	//additional configuration to the task hello
        doLast {
            println "- I depend on mmodule"
        }
    }	
    
 /*
Using the project name for filtering is one option.  (see configure hereunder)
Using extra project properties is another.
*/   
afterEvaluate { Project project ->
        if (project.important) {
            hello.configure {
                doLast {
                    println '- I SHOULD BE STUDIED WITH CARE'
                }
            }
        }
    }

	repositories {
		mavenCentral()
	}

	test {
		useJUnitPlatform()
	}
}

/*
You can add specific behavior on top of the common behavior. 
Usually we put the project specific behavior in the build script of the 
project where we want to apply this specific behavior. 
But as we have already seen, we don’t have to do it this way. 

project(':mmmodule').hello {
    doLast {
        println "- I'm the root project."
    }
}*/
project(':mmlibrary').hello {
    doLast {
        println "- I'm a reusable library"
    }
}

/*
To show more of the power of configuration injection,
add more behavior to the build of mmlibrary via this root build script 
*/
configure(subprojects.findAll {it.name == 'mmlibrary'}) {
    hello {
        doLast {
            println "- I'm a quite naive library...."
        }
    }
}



bootJar {
	enabled = false
}
